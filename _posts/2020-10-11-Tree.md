---
layout: post
title: Tree
key: 20201011
tags:
  - C++
  - data structure and algorithm
  - Tree
---

## 1.Tree Definition
```c++
//Tree Declaration
struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode():val(0),left(nullptr),right(nullptr){};
    TreeNode(int x):val(x),left(nullptr),right(nullptr){};
    TreeNode(int x, TreeNode* l,TreeNode* r):val(x),left(l),right(r){};
};
//Tree Initializaiton with default value zero
TreeNode *root = new TreeNode(0, nullptr, nullptr);
```
<!--more-->
## 2.Binary Search Tree
### 2.1 Binary Search Tree Definition  
Binary Search Tree is a node-based binary tree data structure which has following structures:
* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys larger than the node's key.
*  The left and right subtree each must also be a binary search tree.

### 2.2 Binary Search Tree Basic Operation

### 2.3 Binary Search Tree Construction:
* 96 Unique Binary Search Trees ([Q](https://leetcode.com/problems/unique-binary-search-trees/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/96_unique_binary_search_tree.cpp))(DFS)

* 95 Unique Binary Search Tree_II ([Q](https://leetcode.com/problems/unique-binary-search-trees-ii/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/95_unique_binary_search_tree_2.cpp))(DP)


### 2.4 Path:
* 113 Path Sum II([Q](https://leetcode.com/problems/path-sum-ii/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/113_path_sum_3.cpp))(DFS)


### 2.5 Modify Tree Data Structure
#### 2.5.1 Flatten Binary Tree(DFS):
* 114 Flatten Binary Tree to Linked List([Q](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/114_flatten_bianry_tree_to_linked_list.cpp))   

Since every depth search we need tail of left subtree to be connected to top of right subtree, return tail of every flatten root is necessary.
{:.info}

Don't forget to set root left tree to be nullptr.
{:.warning}

#### 2.5.2 Next Pointer
* 116 Populating Next Right Pointers in Each Node([Q](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/116_populating_next_right_pointers_in_each_node.cpp))  

We need to build 'next' connection between four tree nodes from their two root tree nodes.
{:.info}

Given dicussion above, dfs function would be like:
```c++
    void func(TreeNode* left, TreeNode *right){}
```

* 117 Populating Next Right Pointers in Each Node II([Q](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/):[A](https://github.com/Hadleyhzy/data_structure_and_algorithm/blob/master/tree/leetcode_tree/117_populating_next_right_pointers_in_each_node_2.cpp))  

Note that better solution would be breadth first search since it's not perfect binary tree.
{:.warning}

